// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class libfmsynth {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  libfmsynth(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  libfmsynth.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// \brief Returns current version of libfmsynth.
  ///
  /// If this mismatches with what the application expects, an ABI mismatch is likely.
  /// @returns Version of libfmsynth.
  int fmsynth_get_version() {
    return _fmsynth_get_version();
  }

  late final _fmsynth_get_version_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_get_version>>(
          'fmsynth_get_version');
  late final _dart_fmsynth_get_version _fmsynth_get_version =
      _fmsynth_get_version_ptr.asFunction<_dart_fmsynth_get_version>();

  /// \addtogroup libfmsynthLifetime Lifetime */
  /// /** @{ */
  /// /** \brief Allocate a new instance of an FM synth.
  ///
  /// Must be freed later with \ref fmsynth_free.
  ///
  /// @param sample_rate Sample rate in Hz for the synthesizer. Cannot be changed once initialized.
  /// @param max_voices The maximum number of simultaneous voices (polyphony) the synth can support. Cannot be changed once initialized.
  ///
  /// @returns Newly allocated instance if successful, otherwise NULL.
  ffi.Pointer<fmsynth> fmsynth_new(
    double sample_rate,
    int max_voices,
  ) {
    return _fmsynth_new(
      sample_rate,
      max_voices,
    );
  }

  late final _fmsynth_new_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_new>>('fmsynth_new');
  late final _dart_fmsynth_new _fmsynth_new =
      _fmsynth_new_ptr.asFunction<_dart_fmsynth_new>();

  /// \brief Reset FM synth state to initial values.
  ///
  /// Resets the internal state as if the instance had just been created using \ref fmsynth_new.
  ///
  /// @param fm Handle to an FM synth instance.
  void fmsynth_reset(
    ffi.Pointer<fmsynth> fm,
  ) {
    return _fmsynth_reset(
      fm,
    );
  }

  late final _fmsynth_reset_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_reset>>('fmsynth_reset');
  late final _dart_fmsynth_reset _fmsynth_reset =
      _fmsynth_reset_ptr.asFunction<_dart_fmsynth_reset>();

  /// \brief Free an FM synth instance.
  ///
  /// @param fm Handle to an FM synth instance.
  void fmsynth_free(
    ffi.Pointer<fmsynth> fm,
  ) {
    return _fmsynth_free(
      fm,
    );
  }

  late final _fmsynth_free_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_free>>('fmsynth_free');
  late final _dart_fmsynth_free _fmsynth_free =
      _fmsynth_free_ptr.asFunction<_dart_fmsynth_free>();

  /// \brief Set a parameter specific to an operator.
  ///
  /// If either parameter or operator_index is out of bounds, this functions is a no-op.
  /// Updated parameters will not generally be reflected in audio output until a new voice has started.
  ///
  /// @param fm Handle to an FM synth instance.
  /// @param parameter Which parameter to modify. See \ref fmsynth_parameter for which parameters can be used.
  /// @param operator_index Which operator to modify. Valid range is 0 to \ref FMSYNTH_OPERATORS - 1.
  /// @param value A floating point value. The meaning is parameter-dependent.
  void fmsynth_set_parameter(
    ffi.Pointer<fmsynth> fm,
    int parameter,
    int operator_index,
    double value,
  ) {
    return _fmsynth_set_parameter(
      fm,
      parameter,
      operator_index,
      value,
    );
  }

  late final _fmsynth_set_parameter_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_set_parameter>>(
          'fmsynth_set_parameter');
  late final _dart_fmsynth_set_parameter _fmsynth_set_parameter =
      _fmsynth_set_parameter_ptr.asFunction<_dart_fmsynth_set_parameter>();

  double fmsynth_get_parameter(
    ffi.Pointer<fmsynth> fm,
    int parameter,
    int operator_index,
  ) {
    return _fmsynth_get_parameter(
      fm,
      parameter,
      operator_index,
    );
  }

  late final _fmsynth_get_parameter_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_get_parameter>>(
          'fmsynth_get_parameter');
  late final _dart_fmsynth_get_parameter _fmsynth_get_parameter =
      _fmsynth_get_parameter_ptr.asFunction<_dart_fmsynth_get_parameter>();

  double fmsynth_convert_from_normalized_parameter(
    ffi.Pointer<fmsynth> fm,
    int parameter,
    double value,
  ) {
    return _fmsynth_convert_from_normalized_parameter(
      fm,
      parameter,
      value,
    );
  }

  late final _fmsynth_convert_from_normalized_parameter_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_convert_from_normalized_parameter>>(
          'fmsynth_convert_from_normalized_parameter');
  late final _dart_fmsynth_convert_from_normalized_parameter
      _fmsynth_convert_from_normalized_parameter =
      _fmsynth_convert_from_normalized_parameter_ptr
          .asFunction<_dart_fmsynth_convert_from_normalized_parameter>();

  double fmsynth_convert_to_normalized_parameter(
    ffi.Pointer<fmsynth> fm,
    int parameter,
    double value,
  ) {
    return _fmsynth_convert_to_normalized_parameter(
      fm,
      parameter,
      value,
    );
  }

  late final _fmsynth_convert_to_normalized_parameter_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_convert_to_normalized_parameter>>(
          'fmsynth_convert_to_normalized_parameter');
  late final _dart_fmsynth_convert_to_normalized_parameter
      _fmsynth_convert_to_normalized_parameter =
      _fmsynth_convert_to_normalized_parameter_ptr
          .asFunction<_dart_fmsynth_convert_to_normalized_parameter>();

  /// \brief Set a parameter global to the FM synth.
  ///
  /// If parameter is out of bounds, this functions is a no-op.
  /// Updated parameters will not generally be reflected in audio output until a new voice has started.
  ///
  /// @param fm Handle to an FM synth instance.
  /// @param parameter Which parameter to modify. See \ref fmsynth_global_parameter for which parameters can be used.
  /// @param value A floating point value. The meaning is parameter-dependent.
  void fmsynth_set_global_parameter(
    ffi.Pointer<fmsynth> fm,
    int parameter,
    double value,
  ) {
    return _fmsynth_set_global_parameter(
      fm,
      parameter,
      value,
    );
  }

  late final _fmsynth_set_global_parameter_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_set_global_parameter>>(
          'fmsynth_set_global_parameter');
  late final _dart_fmsynth_set_global_parameter _fmsynth_set_global_parameter =
      _fmsynth_set_global_parameter_ptr
          .asFunction<_dart_fmsynth_set_global_parameter>();

  double fmsynth_get_global_parameter(
    ffi.Pointer<fmsynth> fm,
    int parameter,
  ) {
    return _fmsynth_get_global_parameter(
      fm,
      parameter,
    );
  }

  late final _fmsynth_get_global_parameter_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_get_global_parameter>>(
          'fmsynth_get_global_parameter');
  late final _dart_fmsynth_get_global_parameter _fmsynth_get_global_parameter =
      _fmsynth_get_global_parameter_ptr
          .asFunction<_dart_fmsynth_get_global_parameter>();

  double fmsynth_convert_from_normalized_global_parameter(
    ffi.Pointer<fmsynth> fm,
    int parameter,
    double value,
  ) {
    return _fmsynth_convert_from_normalized_global_parameter(
      fm,
      parameter,
      value,
    );
  }

  late final _fmsynth_convert_from_normalized_global_parameter_ptr = _lookup<
          ffi.NativeFunction<
              _c_fmsynth_convert_from_normalized_global_parameter>>(
      'fmsynth_convert_from_normalized_global_parameter');
  late final _dart_fmsynth_convert_from_normalized_global_parameter
      _fmsynth_convert_from_normalized_global_parameter =
      _fmsynth_convert_from_normalized_global_parameter_ptr
          .asFunction<_dart_fmsynth_convert_from_normalized_global_parameter>();

  double fmsynth_convert_to_normalized_global_parameter(
    ffi.Pointer<fmsynth> fm,
    int parameter,
    double value,
  ) {
    return _fmsynth_convert_to_normalized_global_parameter(
      fm,
      parameter,
      value,
    );
  }

  late final _fmsynth_convert_to_normalized_global_parameter_ptr = _lookup<
          ffi.NativeFunction<
              _c_fmsynth_convert_to_normalized_global_parameter>>(
      'fmsynth_convert_to_normalized_global_parameter');
  late final _dart_fmsynth_convert_to_normalized_global_parameter
      _fmsynth_convert_to_normalized_global_parameter =
      _fmsynth_convert_to_normalized_global_parameter_ptr
          .asFunction<_dart_fmsynth_convert_to_normalized_global_parameter>();

  /// \brief Size in bytes required to hold a preset in memory.
  ///
  /// @returns Required size.
  int fmsynth_preset_size() {
    return _fmsynth_preset_size();
  }

  late final _fmsynth_preset_size_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_preset_size>>(
          'fmsynth_preset_size');
  late final _dart_fmsynth_preset_size _fmsynth_preset_size =
      _fmsynth_preset_size_ptr.asFunction<_dart_fmsynth_preset_size>();

  /// \brief Saves current preset to memory.
  ///
  /// The current preset state of the synth is stored to memory.
  /// The preset state is portable across platforms and can be stored to disk safely.
  ///
  /// @param fm Handle to an FM synth interface.
  /// @param metadata Pointer to metadata. Can be NULL if no metadata is desired.
  /// @param buffer Pointer to buffer where preset is stored.
  /// @param size Size of buffer. Must be at least \ref fmsynth_preset_size.
  ///
  /// @returns Error code.
  int fmsynth_preset_save(
    ffi.Pointer<fmsynth> fm,
    ffi.Pointer<fmsynth_preset_metadata> metadata,
    ffi.Pointer<ffi.Void> buffer,
    int size,
  ) {
    return _fmsynth_preset_save(
      fm,
      metadata,
      buffer,
      size,
    );
  }

  late final _fmsynth_preset_save_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_preset_save>>(
          'fmsynth_preset_save');
  late final _dart_fmsynth_preset_save _fmsynth_preset_save =
      _fmsynth_preset_save_ptr.asFunction<_dart_fmsynth_preset_save>();

  /// \brief Load preset from memory.
  ///
  /// The current preset state of the synth is stored to memory.
  /// The preset state is portable across platforms and can be stored to disk safely.
  ///
  /// @param fm Handle to an FM synth interface.
  /// @param metadata Pointer to metadata. Can be NULL if reading metadata is not necessary.
  /// @param buffer Pointer to buffer where preset can be read.
  /// @param size Size of buffer. Must be at least \ref fmsynth_preset_size.
  ///
  /// @returns Error code.
  int fmsynth_preset_load(
    ffi.Pointer<fmsynth> fm,
    ffi.Pointer<fmsynth_preset_metadata> metadata,
    ffi.Pointer<ffi.Void> buffer,
    int size,
  ) {
    return _fmsynth_preset_load(
      fm,
      metadata,
      buffer,
      size,
    );
  }

  late final _fmsynth_preset_load_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_preset_load>>(
          'fmsynth_preset_load');
  late final _dart_fmsynth_preset_load _fmsynth_preset_load =
      _fmsynth_preset_load_ptr.asFunction<_dart_fmsynth_preset_load>();

  /// \addtogroup libfmsynthRender Audio rendering */
  /// /** @{ */
  /// /** \brief Render audio to buffer
  ///
  /// Renders audio to left and right buffers. The rendering is additive.
  /// Ensure that left and right channels are cleared to zero or contains other audio before calling this function.
  ///
  /// @param fm Handle to an FM synth instance.
  /// @param left A pointer to buffer representing the left channel.
  /// @param right A pointer to buffer representing the right channel.
  /// @param frames The number of frames (left and right samples) to render.
  ///
  /// @returns Number of voices currently active.
  int fmsynth_render(
    ffi.Pointer<fmsynth> fm,
    ffi.Pointer<ffi.Float> left,
    ffi.Pointer<ffi.Float> right,
    int frames,
  ) {
    return _fmsynth_render(
      fm,
      left,
      right,
      frames,
    );
  }

  late final _fmsynth_render_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_render>>('fmsynth_render');
  late final _dart_fmsynth_render _fmsynth_render =
      _fmsynth_render_ptr.asFunction<_dart_fmsynth_render>();

  /// \addtogroup libfmsynthControl MIDI control interface */
  /// /** @{ */
  /// /** \brief Trigger a note on the FM synth.
  ///
  /// @param fm Handle to an FM synth instance.
  /// @param note Which note to press. Note is parsed using MIDI rules, i.e. note = 69 is A4. Valid range is [0, 127].
  /// @param velocity Note velocity. Velocity is parsed using MIDI rules. valie range is [0, 127].
  ///
  /// @returns \ref FMSYNTH_STATUS_OK or \ref FMSYNTH_STATUS_BUSY if polyphony is exhausted.
  int fmsynth_note_on(
    ffi.Pointer<fmsynth> fm,
    int note,
    int velocity,
  ) {
    return _fmsynth_note_on(
      fm,
      note,
      velocity,
    );
  }

  late final _fmsynth_note_on_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_note_on>>('fmsynth_note_on');
  late final _dart_fmsynth_note_on _fmsynth_note_on =
      _fmsynth_note_on_ptr.asFunction<_dart_fmsynth_note_on>();

  /// \brief Release a note on the FM synth.
  ///
  /// @param fm Handle to an FM synth instance.
  /// @param note Which note to release.
  /// All currently pressed notes which match this will be put into either released state or
  /// sustained state depending on if sustain is currently held. See \ref fmsynth_set_sustain.
  void fmsynth_note_off(
    ffi.Pointer<fmsynth> fm,
    int note,
  ) {
    return _fmsynth_note_off(
      fm,
      note,
    );
  }

  late final _fmsynth_note_off_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_note_off>>('fmsynth_note_off');
  late final _dart_fmsynth_note_off _fmsynth_note_off =
      _fmsynth_note_off_ptr.asFunction<_dart_fmsynth_note_off>();

  /// \brief Set sustain state for FM synth.
  ///
  /// If sustain is held and notes are released, notes will be put in a sustain state instead.
  /// Sustained notes will not be released until sustain is released as well.
  ///
  /// @param fm Handle to an FM synth instance.
  /// @param enable If true, hold sustain. If false, release sustain, potentially releasing notes as well.
  void fmsynth_set_sustain(
    ffi.Pointer<fmsynth> fm,
    bool enable,
  ) {
    return _fmsynth_set_sustain(
      fm,
      enable ? 1 : 0,
    );
  }

  late final _fmsynth_set_sustain_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_set_sustain>>(
          'fmsynth_set_sustain');
  late final _dart_fmsynth_set_sustain _fmsynth_set_sustain =
      _fmsynth_set_sustain_ptr.asFunction<_dart_fmsynth_set_sustain>();

  /// \brief Set modulation wheel state.
  ///
  /// @param fm Handle to an FM synth instance.
  /// @param wheel wheel is parsed using MIDI rules. Valid range is [0, 127]. Intial state is 0.
  void fmsynth_set_mod_wheel(
    ffi.Pointer<fmsynth> fm,
    int wheel,
  ) {
    return _fmsynth_set_mod_wheel(
      fm,
      wheel,
    );
  }

  late final _fmsynth_set_mod_wheel_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_set_mod_wheel>>(
          'fmsynth_set_mod_wheel');
  late final _dart_fmsynth_set_mod_wheel _fmsynth_set_mod_wheel =
      _fmsynth_set_mod_wheel_ptr.asFunction<_dart_fmsynth_set_mod_wheel>();

  /// \brief Set pitch bend state.
  ///
  /// @param fm Handle to an FM synth instance.
  /// @param value value is parsed using MIDI rules. Value range is [0, 0x3fff]. Initial state is 0x2000 (centered).
  /// Range for pitch bend is two semitones.
  void fmsynth_set_pitch_bend(
    ffi.Pointer<fmsynth> fm,
    int value,
  ) {
    return _fmsynth_set_pitch_bend(
      fm,
      value,
    );
  }

  late final _fmsynth_set_pitch_bend_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_set_pitch_bend>>(
          'fmsynth_set_pitch_bend');
  late final _dart_fmsynth_set_pitch_bend _fmsynth_set_pitch_bend =
      _fmsynth_set_pitch_bend_ptr.asFunction<_dart_fmsynth_set_pitch_bend>();

  /// \brief Forcibly release all notes.
  ///
  /// All notes are released, even if sustain is activated.
  /// Sustain is also reset to unpressed state.
  ///
  /// @param fm Handle to an FM synth instance.
  void fmsynth_release_all(
    ffi.Pointer<fmsynth> fm,
  ) {
    return _fmsynth_release_all(
      fm,
    );
  }

  late final _fmsynth_release_all_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_release_all>>(
          'fmsynth_release_all');
  late final _dart_fmsynth_release_all _fmsynth_release_all =
      _fmsynth_release_all_ptr.asFunction<_dart_fmsynth_release_all>();

  /// \brief Parse single MIDI message.
  ///
  /// @param fm Handle to an FM synth instance.
  /// @param midi_data Pointer to MIDI data. Message type must always be provided.
  /// E.g. Successive "note on" messages cannot drop the first byte.
  ///
  /// @returns Status code. Depends on MIDI message type or \ref FMSYNTH_STATUS_MESSAGE_UNKNOWN if unknown MIDI message is provided.
  int fmsynth_parse_midi(
    ffi.Pointer<fmsynth> fm,
    ffi.Pointer<ffi.Uint8> midi_data,
  ) {
    return _fmsynth_parse_midi(
      fm,
      midi_data,
    );
  }

  late final _fmsynth_parse_midi_ptr =
      _lookup<ffi.NativeFunction<_c_fmsynth_parse_midi>>('fmsynth_parse_midi');
  late final _dart_fmsynth_parse_midi _fmsynth_parse_midi =
      _fmsynth_parse_midi_ptr.asFunction<_dart_fmsynth_parse_midi>();
}

class fmsynth extends ffi.Opaque {}

/// Parameters for the synth which are unique per FM operator.
abstract class fmsynth_parameter {
  /// < Linear amplitude for the operator.
  static const int FMSYNTH_PARAM_AMP = 0;

  /// < Panning for operator when it's used as a carrier. -1.0 is left, +1.0 is right, +0.0 is centered.
  static const int FMSYNTH_PARAM_PAN = 1;

  /// < Frequency mod factor. The base frequency of the operator is note frequency times the freq mod.
  /// E.g. A4 with freq mod of 2.0 would be 880 Hz.
  static const int FMSYNTH_PARAM_FREQ_MOD = 2;

  /// < A constant frequency offset applied to the oscillator.
  static const int FMSYNTH_PARAM_FREQ_OFFSET = 3;

  /// < The linear amplitude reached in the envelope after FMSYNTH_PARAM_DELAY0 seconds. Initial amplitude is 0.
  static const int FMSYNTH_PARAM_ENVELOPE_TARGET0 = 4;

  /// < The linear amplitude reached in the envelope after (FMSYNTH_PARAM_DELAY0 + FMSYNTH_PARAM_DELAY1) seconds.
  static const int FMSYNTH_PARAM_ENVELOPE_TARGET1 = 5;

  /// < The linear amplitide reached in the envelope after (FMSYNTH_PARAM_DELAY0 + FMSYNTH_PARAM_DELAY1 + FMSYNTH_PARAM_DELAY2) seconds.
  static const int FMSYNTH_PARAM_ENVELOPE_TARGET2 = 6;

  /// < The time in seconds for the envelope to reach FMSYNTH_PARAM_ENVELOPE_TARGET0.
  static const int FMSYNTH_PARAM_DELAY0 = 7;

  /// < The time in seconds for the envelope to reach FMSYNTH_PARAM_ENVELOPE_TARGET1.
  static const int FMSYNTH_PARAM_DELAY1 = 8;

  /// < The time in seconds for the envelope to reach FMSYNTH_PARAM_ENVELOPE_TARGET2.
  static const int FMSYNTH_PARAM_DELAY2 = 9;

  /// < After releasing the key, the time it takes for the operator to attenuate 60 dB.
  static const int FMSYNTH_PARAM_RELEASE_TIME = 10;

  /// < The frequency which splits the keyboard into a "low" and "high" section.
  /// This frequency only depends on the note itself, not FMSYNTH_PARAM_FREQ_MOD, etc.
  static const int FMSYNTH_PARAM_KEYBOARD_SCALING_MID_POINT = 11;

  /// < Amplitude scaling factor pow(note_frequency / SCALING_MID_POINT, SCALING_LOW_FACTOR) if the key pressed
  /// is in the "low" section of the keyboard.
  /// Negative values will boost amplitide for lower frequency keys and attenuate amplitude for higher frequency keys.
  /// E.g. A value of -1.0 will add a 6 dB attenuation per octave.
  static const int FMSYNTH_PARAM_KEYBOARD_SCALING_LOW_FACTOR = 12;

  /// < Amplitude scaling factor pow(note_frequency / SCALING_MID_POINT, SCALING_HIGH_FACTOR) if the key pressed
  /// is in the "high" section of the keyboard.
  /// Negative values will boost amplitide for lower frequency keys and attenuate amplitude for higher frequency keys.
  /// E.g. A value of -1.0 will add a 6 dB attenuation per octave.
  static const int FMSYNTH_PARAM_KEYBOARD_SCALING_HIGH_FACTOR = 13;

  /// < Controls velocity sensitivity. If 0.0, operator amplitude is independent of key velocity.
  /// If 1.0, the operator amplitude is fully dependent on key velocity.
  /// `factor = (1.0 - VELOCITY_SENSITIVITY) + VELOCITY_SENSITIVITY * velocity`.
  /// `velocity` is normalized to [0, 1].
  static const int FMSYNTH_PARAM_VELOCITY_SENSITIVITY = 14;

  /// < If 0.0, operator amplitude is independent of mod wheel state.
  /// If 1.0, operator amplitude is fully dependent on mod wheel state.
  /// `factor = (1.0 - MOD_WHEEL_SENSITIVITY) + MOD_WHEEL_SENSITIVITY * mod_wheel`.
  /// `mod_wheel` is normalized to [0, 1].
  static const int FMSYNTH_PARAM_MOD_WHEEL_SENSITIVITY = 15;

  /// < Specifies how much the LFO modulates amplitude.
  /// Modulation factor is: 1.0 + lfo_value * LFO_AMP_SENSITIVITY.
  /// lfo_value has a range of [-1, 1].
  static const int FMSYNTH_PARAM_LFO_AMP_SENSITIVITY = 16;

  /// < Specifies how much the LFO modulates frequency.
  /// Modulation factor is: 1.0 + lfo_value * LFO_FREQ_MOD_DEPTH.
  /// lfo_value has a range of [-1, 1].
  static const int FMSYNTH_PARAM_LFO_FREQ_MOD_DEPTH = 17;

  /// < Enable operator if value > 0.5, otherwise, disable.
  static const int FMSYNTH_PARAM_ENABLE = 18;

  /// < Set carrier mixing factor. If > 0.0, the operator will generate audio that is mixed into the final output.
  static const int FMSYNTH_PARAM_CARRIERS = 19;

  /// < Sets how much the operator will modulate carrier `N`. Use `FMSYNTH_PARAM_MOD_TO_CARRIERS0 + N` to specify which operator is the modulator target.
  static const int FMSYNTH_PARAM_MOD_TO_CARRIERS0 = 20;

  /// < The number of parameters available.
  static const int FMSYNTH_PARAM_END = 28;

  /// < Ensure the enum is sizeof(int).
  static const int FMSYNTH_PARAM_ENSURE_INT = 2147483647;
}

/// Parameters which are global to the entire synth.
abstract class fmsynth_global_parameter {
  /// < Overall volume of the synth.
  static const int FMSYNTH_GLOBAL_PARAM_VOLUME = 0;

  /// < LFO frequency in Hz.
  static const int FMSYNTH_GLOBAL_PARAM_LFO_FREQ = 1;

  /// < The number of global parameters available.
  static const int FMSYNTH_GLOBAL_PARAM_END = 2;

  /// < Ensure the enum is sizeof(int).
  static const int FMSYNTH_GLOBAL_PARAM_ENSURE_INT = 2147483647;
}

/// Generic status code for certain functions.
abstract class fmsynth_status_t {
  /// < Operation completed successfully.
  static const int FMSYNTH_STATUS_OK = 0;

  /// < Operation could not complete due to insufficient resources at the moment.
  static const int FMSYNTH_STATUS_BUSY = 1;

  /// < Provided buffer is too small.
  static const int FMSYNTH_STATUS_BUFFER_TOO_SMALL = 2;

  /// < Metadata string was not properly NUL-terminated.
  static const int FMSYNTH_STATUS_NO_NUL_TERMINATE = 3;

  /// < Provided buffer does not adhere to specified format.
  static const int FMSYNTH_STATUS_INVALID_FORMAT = 4;

  /// < Provided MIDI message is unknown.
  static const int FMSYNTH_STATUS_MESSAGE_UNKNOWN = 5;

  /// < Ensure the enum is sizeof(int).
  static const int FMSYNTH_STATUS_ENSURE_INT = 2147483647;
}

/// Metadata structure for presets.
/// UTF-8 is assumed. API does not validate that however.
/// Strings must be properly NUL-terminated.
class fmsynth_preset_metadata extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Int8> name;

  @ffi.Array.multi([64])
  external ffi.Array<ffi.Int8> author;
}

const int FMSYNTH_OPERATORS = 8;

const int FMSYNTH_VERSION = 2;

const int FMSYNTH_PRESET_STRING_SIZE = 64;

typedef _c_fmsynth_get_version = ffi.Uint32 Function();

typedef _dart_fmsynth_get_version = int Function();

typedef _c_fmsynth_new = ffi.Pointer<fmsynth> Function(
  ffi.Float sample_rate,
  ffi.Uint32 max_voices,
);

typedef _dart_fmsynth_new = ffi.Pointer<fmsynth> Function(
  double sample_rate,
  int max_voices,
);

typedef _c_fmsynth_reset = ffi.Void Function(
  ffi.Pointer<fmsynth> fm,
);

typedef _dart_fmsynth_reset = void Function(
  ffi.Pointer<fmsynth> fm,
);

typedef _c_fmsynth_free = ffi.Void Function(
  ffi.Pointer<fmsynth> fm,
);

typedef _dart_fmsynth_free = void Function(
  ffi.Pointer<fmsynth> fm,
);

typedef _c_fmsynth_set_parameter = ffi.Void Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint32 parameter,
  ffi.Uint32 operator_index,
  ffi.Float value,
);

typedef _dart_fmsynth_set_parameter = void Function(
  ffi.Pointer<fmsynth> fm,
  int parameter,
  int operator_index,
  double value,
);

typedef _c_fmsynth_get_parameter = ffi.Float Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint32 parameter,
  ffi.Uint32 operator_index,
);

typedef _dart_fmsynth_get_parameter = double Function(
  ffi.Pointer<fmsynth> fm,
  int parameter,
  int operator_index,
);

typedef _c_fmsynth_convert_from_normalized_parameter = ffi.Float Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint32 parameter,
  ffi.Float value,
);

typedef _dart_fmsynth_convert_from_normalized_parameter = double Function(
  ffi.Pointer<fmsynth> fm,
  int parameter,
  double value,
);

typedef _c_fmsynth_convert_to_normalized_parameter = ffi.Float Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint32 parameter,
  ffi.Float value,
);

typedef _dart_fmsynth_convert_to_normalized_parameter = double Function(
  ffi.Pointer<fmsynth> fm,
  int parameter,
  double value,
);

typedef _c_fmsynth_set_global_parameter = ffi.Void Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint32 parameter,
  ffi.Float value,
);

typedef _dart_fmsynth_set_global_parameter = void Function(
  ffi.Pointer<fmsynth> fm,
  int parameter,
  double value,
);

typedef _c_fmsynth_get_global_parameter = ffi.Float Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint32 parameter,
);

typedef _dart_fmsynth_get_global_parameter = double Function(
  ffi.Pointer<fmsynth> fm,
  int parameter,
);

typedef _c_fmsynth_convert_from_normalized_global_parameter = ffi.Float
    Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint32 parameter,
  ffi.Float value,
);

typedef _dart_fmsynth_convert_from_normalized_global_parameter = double
    Function(
  ffi.Pointer<fmsynth> fm,
  int parameter,
  double value,
);

typedef _c_fmsynth_convert_to_normalized_global_parameter = ffi.Float Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint32 parameter,
  ffi.Float value,
);

typedef _dart_fmsynth_convert_to_normalized_global_parameter = double Function(
  ffi.Pointer<fmsynth> fm,
  int parameter,
  double value,
);

typedef _c_fmsynth_preset_size = ffi.Uint64 Function();

typedef _dart_fmsynth_preset_size = int Function();

typedef _c_fmsynth_preset_save = ffi.Int32 Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Pointer<fmsynth_preset_metadata> metadata,
  ffi.Pointer<ffi.Void> buffer,
  ffi.Uint64 size,
);

typedef _dart_fmsynth_preset_save = int Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Pointer<fmsynth_preset_metadata> metadata,
  ffi.Pointer<ffi.Void> buffer,
  int size,
);

typedef _c_fmsynth_preset_load = ffi.Int32 Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Pointer<fmsynth_preset_metadata> metadata,
  ffi.Pointer<ffi.Void> buffer,
  ffi.Uint64 size,
);

typedef _dart_fmsynth_preset_load = int Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Pointer<fmsynth_preset_metadata> metadata,
  ffi.Pointer<ffi.Void> buffer,
  int size,
);

typedef _c_fmsynth_render = ffi.Uint32 Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Pointer<ffi.Float> left,
  ffi.Pointer<ffi.Float> right,
  ffi.Uint32 frames,
);

typedef _dart_fmsynth_render = int Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Pointer<ffi.Float> left,
  ffi.Pointer<ffi.Float> right,
  int frames,
);

typedef _c_fmsynth_note_on = ffi.Int32 Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint8 note,
  ffi.Uint8 velocity,
);

typedef _dart_fmsynth_note_on = int Function(
  ffi.Pointer<fmsynth> fm,
  int note,
  int velocity,
);

typedef _c_fmsynth_note_off = ffi.Void Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint8 note,
);

typedef _dart_fmsynth_note_off = void Function(
  ffi.Pointer<fmsynth> fm,
  int note,
);

typedef _c_fmsynth_set_sustain = ffi.Void Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint8 enable,
);

typedef _dart_fmsynth_set_sustain = void Function(
  ffi.Pointer<fmsynth> fm,
  int enable,
);

typedef _c_fmsynth_set_mod_wheel = ffi.Void Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint8 wheel,
);

typedef _dart_fmsynth_set_mod_wheel = void Function(
  ffi.Pointer<fmsynth> fm,
  int wheel,
);

typedef _c_fmsynth_set_pitch_bend = ffi.Void Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Uint16 value,
);

typedef _dart_fmsynth_set_pitch_bend = void Function(
  ffi.Pointer<fmsynth> fm,
  int value,
);

typedef _c_fmsynth_release_all = ffi.Void Function(
  ffi.Pointer<fmsynth> fm,
);

typedef _dart_fmsynth_release_all = void Function(
  ffi.Pointer<fmsynth> fm,
);

typedef _c_fmsynth_parse_midi = ffi.Int32 Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Pointer<ffi.Uint8> midi_data,
);

typedef _dart_fmsynth_parse_midi = int Function(
  ffi.Pointer<fmsynth> fm,
  ffi.Pointer<ffi.Uint8> midi_data,
);
